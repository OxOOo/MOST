# MOST

## 编译

```sh
mkdir build
cd build
cmake ..
make
```

## 运行

两个进程，一个进程跑3和1，另一个跑4和2。

```sh
./run_ultimate0.sh
./run_ultimate1.sh
```

## 数据

N  = 256
M1 = 20220217214410
M2 = 104648257118348370704723119
M3 = 125000000000000140750000000000052207500000000006359661
M4 = 3^50 * 7^30 * 11^20

## 优化基础

优化基础是中国剩余定理，使得我们可以将一个取余变成多个小的取余。

比如，M3 = 125000000000000140750000000000052207500000000006359661 = 500000000000000147 * 500000000000000207 * 500000000000000209，可以找长度不超过N并且求余这3个数均为0的数字就是符合条件的数字。

同样，可以发现接收到的数据流并不是等概率的(如果每一位都是0到9均匀随机，实际上很难生成符合条件的数字)。

所以，可以尽量省一些计算量，比如：

1. M1 = 20220217214410，变成计算求余20079859为0并且最后一位为0的数字
2. M2是个素数，没法优化
3. 只需要计算求余500000000000000147等于0的数字
4. 只需要计算求余11^7等于0的数字

上面的转换之后，不会漏掉正确的数字，但是一些错误的数字也会被检测到。实际统计下来错误数量还能够承受。

最终，M1和M4可以使用int32计算，M2使用int128计算，M3使用int64计算。

## 最终的方案

考虑我们一次性接收到了长度为n的字符串S，如果这之中有答案的话：

1. 和之前接收到的字符串拼成一个答案
2. 答案完全在字符串S中

对于第1种情况，考虑之前的数字a和字符串S的长度为k的前缀(数值是b)拼成答案，那么:

a * 10^k + b 同余 0

所以 a 同余 -b * inv(10^k)。

可以枚举k，计算出b，就能知道需要的a是多少。

方案就是：提前预处理N的a，并且放到bitmap中，接收到新字符串的时候，枚举k，计算出b，在bitmap中找是否有合适的a。

对于第2种情况，也是类似的处理方案。为了讨论方便，使用prefix[i]表示S的前i个字符构成的数字。

如果字符串S中区间[l, r]部分是一个答案，那么:

prefix[r] - prefix[l-1] * 10 ^ (r-l+1) 同余0

prefix[r] 同余 prefix[l-1] * 10 ^ (r-l+1)

prefix[r] * 10 ^ (-r) 同余 prefix[l-1] * 10 ^ (-l+1)

所以可以将prefix[l-1] * 10 ^ (-l+1)存起来，然后枚举r，找是否有符合条件的prefix[l-1] * 10 ^ (-l+1)。

同样使用bitmap优化。

## 跑偏了的方案

考虑不断在后面追加1个字符，维护长度为N的后缀，每次添加字符就更新N个后缀，如果某个后缀变成0了就是一个答案。

见`algorithm/`:

- `am1.h`
- `am2_predict.h`
- `am3.h`
- `am4_fast.h`

## 其他优化

1. 编译选项优化：O3，循环展开，向量化等
2. 内存对齐
3. 使用vtune查看热点(基本上都在求余运算上)
